/// ------ PARTE 1 -------- ///

// Separando os arquivos

Crio a pasta GoBarber
>>> yarn init -y
>>> yarn add express

Criar uma pasta src
Dentro dela crio os arquivos:
        app.js      // Configuração do server.express
        server.js   // Servidor
        routes.js   // Rotas

// ----- app.js ------ //
Começo importando express
Importo routes

Defino a primeira class, no caso a app
    Método constructor // executado automaticamente
        dentro dele eu crio uma variável com o express
        chamo os métodos middlewares e routes

Defino os 2 métodos, middlewares e routes
    middlewares -> vai fazer a leitura de json
    routes 		-> vai rodar o arquivo routes.js

Exporta uma nova instância de app, jogando pra server


// ------ server.js ------ //
Crio a parte de Servidor
importo o app.js
Criou um listen de app


// ----- routes ----- //
Importo o {Router} de express -> separando a parte de roteamento
Defino uma variável routes

crio uma rota normal, para teste

module.export routes

>>> node src/server.js

/// ------ PARTE 2 ----- ///
--- import/export -> O node não suporta
adiciono sucrase e nodemon como dependencia da aplicação
>>> yarn add sucrase nodemon -D

altero o const por import e require por from
module.export -> export default

>>> yarn sucrase-node src/server.js //rodar o server

// package.json - dev e debug
crio nodemon.json
nas config do debug


///  ----- PARTE 3 ----- ////
Instalação do docker
Postgres dockerhub tem as variáveis ambientes
Postbird


>>> sudo docker run --name database -e POSTGRES_PASSWORD=docker -p 5432:5432 -d postgres:11

No postbird
	localhost
	5432
	postgres
	docker

Testar a conexão, salvar
Create database


/// ---- PARTE 4 ---- ///
Padronização do código
>>> yarn add eslint -D // Vai garantir que estou seguindo meus padrões
>>> yarn eslint --init

Remover o arquivo package-lock
>>> yarn // para fazer o mapeamento no yarn.lock

Instalar o plugin eslint
configuro o settings.json


//prettier
>>> yarn add prettier eslint-config-prettier eslint-plugin-prettier -D

//no .eslintrc
configuro as rules
configuro plugins

crio um arquivo .prettierrc

>>>yarn eslint --fix src --ext .js

// instala o plugin editorconfig
Mantém um padrão caso os desenvolvedores da equipe usem outro editor
vai na raiz do projeto, botão direito -> generate editor.config
adiciona algumas configurações


/// -----  PARTE 5 ---- ///
Configurar sequelize e estruturar as pastas
Dentro de src
  crio a pasta config
    crio o arquivo database.js // Armazenará as credenciais da base de dados

  crio a pasta database

  crio a pasta app // Aqui ficará a regra de negócio, lógica da aplicação
    pasta controllers
    pasta models

>>> yarn add sequelize
>>> yarn add sequelize-cli -D -> facilita a criação de migrations

Crio na raiz o arquivo .sequelizerc

/// --- database.js --- ///
>> yarn add pg pg-hstore // para poder usar o dialect


/// ----- PARTE 6 ---- ///
Criando a tabela de usuários da app

>>> yarn sequelize migration:create --name=create-users //create users pq é a tabela q vai criar a tabela de usuários
Vai criar uma pasta migrations e dentro da pasta migrations vai criar um arquivo
Configura a migration, passando os dados da tabela como id, name, email // Muito importante ver se os nomes estão certos, se está escrevendo em inglês

>>> yarn sequelize db:migrate

>>> yarn sequelize db:migrate:undo //desfaz a migrate

No Postbird, atualiza -> a tabela já estará lá


//// ----- PARTE 7 ---- ////
MODEL DE USUÁRIO - MANIPULAR OS USERS

Dentro de models
  User.js

Começo importando o Sequelize, Model do sequelize
Defino uma class pai
Dentro eu com um metodo init, com sequelize como parêmetro
Crio um objeto, um outro método, super.init() // referente a class pai
Como primeiro parâmetro passo um objeto com as informações que o usuário preencherá
Como segundo parâmetro passo o sequelize
Exporto por padrão a class User

///----- PARTE 8 ----- ///
//Conexão com o banco de dados

Dentro de database
  crio o arquivo index.js

Importo Sequelize
Importo User // model
Importo databaseConfig // vai puxar as credenciais do database

Crio uma class para fazer a conexão com o banco de dados
Na constructor eu chamo o método init
No método init eu crio uma variável que fará a conexão com o banco de dados
  Essa variável está sendo esperada dentro dos models

Crio um array para os models
Percorro ele, retornando a variável connection para dentro do init

Depois disso, preciso chamar esse arquivo no app.js
  Apenas chamar

Para testar, vou em rotas e crio um json
Caso não esteja funcionando, tentar mudar o email


//// ----- PARTE 9 ----- ////
Criando o controller
Dentro de controllers
  userController

Como sempre estará usando o model de usuário, importar o User
Crio o método store, q terá basicamente a funcionalidade do server.post
Tenho a variável q recebe o req.body e o res q retorna o valor da variável

Vou em rotas, importo o userController
Gero uma rota post passando o método store de userController

Crio uma condição no userController, para ver se não existe um user com o mesmo email

//Insomnia -> por enquanto será alimentado no Insomnia
Crio a pasta USERS
  Create POST json
    passo as informações q quero receber


//// ------ PARTE 10 ------ ////
//Gerando o hash

>>> yarn add bcryptjs
No User.js
	Importo bcrypt from bcryptjs

Crio um campo password dentro do primeiro parâmetro

Crio uma variavel this.addHook -> É executada de forma automática
Passo a password_hash -> pegando o valor criptografado

No Insomnia, altero para password
e ta pronto o sorvetinho

/// ----- PARTE 11 ----- ///
//Autenticação do usuário

Crio a class sessionControler
Com o método store

>>> yarn add jsonwebtoken
Importar o jwt de dentro do jsonwebtoken

A autenticação será através do email e senha

Foi criada uma validação do email, pra checar se existe
Dentro de User.js, foi criada uma validação da senha, para comparar a senha digitada com a senha armazanada no banco de dados

Foi gerado um token, esse token pegou o id do usuário, um código aleatório gerado pelo md5 online e tmb o tempo de expiração


/// ----- PARTE 12 ----- ///
//Bloqueando o usuário caso não esteja logado

Separo a data de expiração e a chave gerada pelo md5, em outro arquivo

Dentro de auth.js crio uma condição para ver se o usuário está autenticado
Separo o Bearer do token

Crio um try catch, se tudo der certo ele retorna o id do usuário


/// ----- PARTE 13 ----- ///
//Edição dos dados do usuário
Crio verificações a respeito de email e password
Se o usuário informar a oldPassword, ele quer atualizar a senha



/// ---- PARTE 14 ---- ///
Validação de dados, se o usuário preencheu corretamente
Biblioteca yup -> schema validation
>>> yarn add yup

import * as 'Yup' from 'yup'

no userController
Foram criadas validações do yup

confirmPassword: Yup.string().when('password', (password, field) =>
        password ? field.required().oneOf([Yup.ref('password')]) : field
//dessa maneira, passo como referência o valor da password

no sessionControler foi criada uma validação para a autenticação também


{{{{{{{{{{{{{{{{{{{{{{{

Para funcionar:
>>> yarn dev
>>> sudo docker start datase

}}}}}}}}}}}}}}}}}}}}}}}


----- ATÉ AQUI MÓDULO 2 TÁ LINDO E MARAVILHOSO FUNCIONANDO ------

/// PARTE 14
//Configurando Multer
Upload de arquivo
Precisa de uma biblioteca que leia um corpo diferente (Multipart/form-Data)
>>> yarn add multer
Criar uma pasta na raiz do projeto (temp/uploads)
Dentro da CONFIG -> multer.js (vai ficar toda nossa configuração da parte de arquivo)
Em routes é importado o multer e configMulter
No Insomnia -> Foi criada uma pasta Files - POST - Multipart Form
     file (nome escolhido la nas rotas)
     setinha para baixo -> seleciona o file
         choose file
  Ctrl+E (Manager enviroment) -> adiciono o token
  Bearer Auth -> substituir o token pela variavél token, como se fosse o base_url
  Depois dar o send
O arquivo será importado em temp/uploads

/// PARTE 15
// Salvando as informações do arquivo na base de dados
Toda vez q multer age sob uma rota, é gerada uma variável dentro de req == req.file
Criado um FileSession, importar nas rotas
Gerar uma migrate create-files

>>> yarn sequelize migration:create --name=create-files
Configuro a migration, mudo o nome de users para files

>>> yarn sequelize db:migrate

Criar um model de Files
Para fazer a conexão com o banco de dados, é importado o model de files no index.js

Ao rodar no Insomnia irá armazenar as info no banco de dados
Porém a tabela files não tem um relacionamento com a tabela users

//Sincando a files com a users
Se adicionar um campo novo na tabela de usuários(migration users), a tabela não vai conseguir referenciar, já que
a migration files é criada Depois

Migrations funcionam como uma linha do tempo da database

Criar uma nova migration para adicionar o campo de avatar na tabela de usuários
>>> yarn sequelize migration:create --name=add-avatar
-> ESSA MIGRATION É DIFERENTE DAS TABELAS CRIADAS ATÉ AGORA
configuro como columns
>>> yarn sequelize db:migrate

Atualizo o postbird, a última informação da coluna da tabela users, deverá ser avatar_id

No Insomnia -> crio o o avatar_id, no update
  Porém o model do user não tem o avatar_id

Criar o método associate em model User.js

Verificar se o ID está pegando um valor único para cada user

///PARTE 16
//Listagem de prestadores de serviço

Cria uma rota de Listagem
Cria um novo controller (ProviderController) -> Como é uma nova entidade, querendo listar apenas os prestadores
  Crio uma class que busque todos os providers true.
  Talvez nenhum provider esteja true, basta ir no postbird e trocar o provider de false para true
Após importar os atributos no Provider, para nomear de 'File' para 'avatar', devemos ir no User.js e passar um as:'avatar'

Como não tem nenhuma informação passando a url da imagem, não é possível passar para o front-end
Gerando a URL do arquivo:
  Em file.js, é criado um campo virtual
  Incluído aos atributos 'url' (ProviderController)
  Recurso do express para servir arquivos estáticos, imagens. css, html, que podem ser acessados diretamente pelo navegador

///PARTE 17
//Criando agendamento
Gerar uma nova migration -> create-appointments
  trocar users por appointments,
  referenciar o usuario e provider à tabela appointments
Gerar um db:migrate

Criando o model appointment.js

